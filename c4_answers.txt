1. What is the purpose of the next() function, and how does it contribute to the compilation 
process?

- The next() function in C4 is responsible for lexical analysis, which is the process of reading the source code and breaking it down into tokens. These tokens represent meaningful elements such as keywords, identifiers, numbers, and operators. The function scans the source code character by character, identifying and classifying each part while ignoring whitespace and comments. It maintains the current position in the source file, keeps track of line numbers, and processes escape sequences in string literals. It also ensures that multi-character operators like ==, !=, and <= are correctly identified. By converting raw source code into a structured sequence of tokens, next() plays a crucial role in making the parsing process more efficient and manageable.

2. How does C4 handle symbol resolution (e.g., variables, functions)?

- C4 resolves symbols using a simple symbol table that keeps track of variables, functions, and system calls. Each identifier is assigned a unique hash value, allowing the compiler to quickly check whether a name has been declared before. When encountering a variable or function, the compiler searches the symbol table to determine if it is a global variable, a local variable, or a function. If it is a function call, C4 checks whether it is a built-in system function like printf or a user-defined function. The symbol table also stores the type of each identifier, ensuring that the compiler can perform basic type checking. Unlike more advanced compilers, C4 does not have support for namespaces, scopes beyond simple function-level scoping, or complex symbol resolution mechanisms like class hierarchies.

3. What are the limitations of C4 as a compiler? What features of C does it not support?

- C4 is an extremely minimalistic compiler that supports only a small subset of the C language. It does not support floating-point numbers, structs, unions, or arrays. It lacks many of the standard C libraries, limiting its ability to work with files, strings, and complex data structures. There is no support for macros, preprocessor directives, or function overloading. The compiler does not generate an abstract syntax tree (AST) or perform any sophisticated optimization techniques. It also does not implement modern error handling features, meaning that error messages can be unclear or difficult to debug. Additionally, C4 does not produce standalone machine code but instead generates bytecode for its own virtual machine. Because of these limitations, C4 cannot be used to compile full-scale C programs and is mainly useful for educational purposes or as a minimal example of how a compiler works.

4. How does C4 achieve self-hosting (i.e., compiling itself)? What are the implications of this 
design?

- C4 is self-hosting because it is written in the same restricted subset of C that it is capable of compiling. This means that the source code of C4 avoids using features that the compiler does not support, such as floating-point operations or complex data structures. Self-hosting allows C4 to compile itself, which is a major milestone for any compiler because it demonstrates that the compiler is complete enough to be self-sustaining. However, this design also has significant limitations. Since C4 cannot compile the full C language, any changes to the compiler must remain within its restricted capabilities. This makes extending or modifying C4 more difficult without relying on an external compiler for bootstrapping. Additionally, because C4 does not optimize its generated code, its self-compiled version may not be as efficient as a compiler designed with full optimization features.